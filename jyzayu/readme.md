SQL vs NoSQL

### RDBMS의 개념과 장단점
RDBMS는 데이터를 테이블 형식으로 저장합니다. 각 테이블은 행과 열로 구성되며, SQL을 사용하여 데이터를 관리합니다.

RDBMS의 주요 장점은 데이터의 무결성과 일관성을 보장한다는 점입니다. 왜냐하면 트랜잭션을 통해 데이터의 일관성을 유지할 수 있기 때문입니다.

또한, RDBMS는 복잡한 쿼리를 지원하며, 데이터 간의 관계를 쉽게 표현할 수 있습니다. 왜냐하면 조인 연산을 통해 여러 테이블의 데이터를 결합할 수 있기 때문입니다.

하지만 RDBMS는 스케일 아웃이 어렵고, 대규모 데이터 처리에 한계가 있습니다. 왜냐하면 데이터가 증가할수록 성능이 저하될 수 있기 때문입니다.

따라서, RDBMS는 데이터 안정성이 중요한 애플리케이션에 적합합니다. 예를 들어, 은행 시스템에서 사용될 수 있습니다.


### NoSQL의 개념과 장단점
NoSQL은 다양한 데이터 모델을 지원합니다. NoSQL은 SQL을 사용하지 않으며, 키-밸류, 도큐먼트, 컬럼 패밀리, 그래프 등의 데이터 모델을 지원합니다.

NoSQL의 주요 장점은 높은 확장성과 빠른 응답 속도입니다. 왜냐하면 수평적 확장이 가능하고, 데이터 중복을 허용하기 때문입니다.

또한, NoSQL은 유연한 데이터 모델을 제공하여, 데이터 구조가 자주 변경되는 애플리케이션에 적합합니다. 왜냐하면 스키마가 없거나 동적으로 변경될 수 있기 때문입니다.
스키마가 확정되고 데이터가 많이 쌓인경우 스키마를 수정하는 경우 리스크가 크기 때문에 유연한 스키마가 이점일 수 있습니다.

유연함은 다음을 의미합니다.
- 구조를 정의하지 않고도 문서를 생성할 수 있습니다.
- 각 문서는 고유한 구조를 가질 수 있습니다.
- 구문은 데이터베이스마다 다를 수 있습니다.
- 사용하면서 필드를 추가할 수 있습니다.

하지만 NoSQL은 데이터의 일관성을 보장하지 않으며, 데이터 중복 관리가 필요합니다. 왜냐하면 데이터 중복으로 인해 최신 데이터를 유지하기 위한 추가 작업이 필요하기 때문입니다.

NoSQL은 대규모 데이터 처리와 빠른 응답 속도가 중요한 애플리케이션에 적합합니다. 예를 들어, 소셜 네트워크 서비스나 로그 데이터 저장에 사용될 수 있습니다.

데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)


역정규화를 하면서 전체 데이터 사이즈는 커지지만 쿼리 복잡도가 낮습니다.
 (1:N관계를 최소화하여 JOIN연산을 줄입니다.(수행시간 단축, 저렴한 비용의 대용량 데이터 지원)
 수평확장에 유리하기 떄문에 데이터 사이즈가 커지는 것에 관대합니다.


## NoSQL 데이터 모델링 절차 
다음과 같은 절차를 통해서 NoSQL의 데이터 모델링이 진행 됩니다.


- 도메인 모델 파악하기

- 데이터 출력 형태 디자인(쿼리 결과 디자인)

- 패턴을 이용한 데이터 모델링

- 최적화에 필요한 기능 리스팅

- 후보 NoSQL 선정과 테스트

- 데이터 모델을 선정한 NoSQL에 최적화 및 하드웨어 디자인

### 도메인 모델 파악하기
RDBMS든 NoSQL이든 먼저 도메인 모델을 파악해야 합니다.
어떤 데이터 개체가 있고 데이터 개체 간의 관계가 어떻게 되는지를 파악한 후 ERD를 그립니다.
해당 과정 없이 바로 어플리케이션 관점에서 접근하면 저장할 데이터에 대한 명확한 이해 없이
데이터 모델링을 하는 것이기 때문에 문제가 생길 수 있습니다.


다음 그림은 간단한 블로그 시스템의 도메인 모델입니다.

- 사용자 ID를 기반으로 블로그의 분류를 가진다.

- 분류별로 글을 작성할 수 있습니다.

- 글에 파일을 첨부할 수 있습니다.

- 댓글을 달 수 있습니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/71cc3e4f-8f02-41f1-bf3e-84ce9402ece7)

### 데이터 출력 형태 디자인 (쿼리 결과 디자인)
도메인 모델을 기준으로 어플리케이션에 쿼리 되는 결과 값을 정합니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/9d0a2684-1912-4c29-b3c6-45dca12e6560)

출력화면을 나타낸 것 입니다.

- 블로그 사용자의 포스팅 분류 명들을 목록으로 출력합니다.

- 포스팅 출력 화면은 상단 부터 포스팅 분류명과 제목, 포스팅 날짜, 본문을 출력합니다.

- 차례대로 첨부 파일의 업로드 날짜와 파일명을 출력하고 파일에 대한 링크를 포함시킵니다.

- 댓글에 작정일과 작정자 이름, 댓글 내용을 출력하며 작성자 이름에 이메일 링크를 답니다.

쿼리 결과 값으로 데이터 형태를 나타냅니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/4df81ca6-defd-4654-a4b0-a79566eca14c)

### 패턴을 이용한 데이터 모델링
NoSQL은 Sorting,Grouping,Join 등의 연산을 제공하지 않기 때문에 
NoSQL의 Put/Get 만으로 데이터를 가져 올수 있게 테이블을 다시 정의합니다.


![image](https://github.com/jyzayu/tech-interview/assets/55649979/7a30ee8e-192b-492b-ad9c-c4a42e0ef627)

블로그 NoSQL 테이블 구조를 나타낸 것 입니다.

Ordered Key/Value Store의 경우 그림과 같이 Key를 생성하면

postId를 순서대로 증가해 가면서 사용자 글이 정렬 되는 기능을 합니다.

검색시 특정 userId의 postId가 순서대로 출력되다 userId가 바뀌면
해당 post부터 다른 user가 장석한 post이기 때문에 그룹화 기능이 됩니다.

### 최적화에 필요한 기능 리스팅
첨부 파일(Attachment)은 Document Store를 고려해야 합니다. 첨부 파일은 Posting이 작성된 후 레코드가 추가되며 변경이 거의 없다. 또한 많은 양이 아니기 때문에 하나의 필드에 저장할수 있습니다.


카테고리(category)가 있기 때문에 카테고리 별로 분류되어 검색이 가능해야 합니다.
카테고리에 따라 Posting을 출력하려면 Posting의 카테고리 필드에 
저장되고 조건에 따라 검색이 가능해야 합니다. 
이런 이유로 카테고리는 NoSQL의 Secondary Index를 고려해야 합니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/0c5c0e16-ba39-472a-9dde-9d98cc0d4dd1)

### 후보 NoSQL 선정과 테스트
이렇게 모델링한 데이터 구조를 효과적으로 실행할 수 있는 NoSQL을 찾고
해당 NoSQL의 특성, 부하, 안정성, 확장성 등의 테스트를 모두 거친후 선택해야 합니다.

또한 각 서비스에 대하여 데이터 형태와 업무의 목적에 따라 맞는
여러개의 NoSQL을 복합하여 사용할 수도 있습니다.

### 데이터 모델을 선정한 NoSQL에 최정화 및 하드웨어 디자인
마지막으로 선택한 NoSQL을 기반으로 어플리케이션 인터페이스 설계와 하드웨어 디자인을 진행하면 됩니다.



### RDBMS와 NoSQL의 선택 기준

애플리케이션의 요구 사항에 따라 RDBMS와 NoSQL을 선택하는 기준을 정리해보겠습니다. 

첫째, 데이터 안정성이 중요한 경우 RDBMS를 선택하는 것이 좋습니다. 왜냐하면 트랜잭션을 통해 데이터의 일관성을 유지할 수 있기 때문입니다.

둘째, 대규모 데이터 처리와 빠른 응답 속도가 중요한 경우 NoSQL을 선택하는 것이 좋습니다. 왜냐하면 수평적 확장이 가능하고, 데이터 중복을 허용하기 때문입니다.
NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적입니다


셋째, 데이터 구조가 자주 변경되는 경우 NoSQL을 선택하는 것이 좋습니다. 왜냐하면 유연한 데이터 모델을 제공하기 때문입니다.
(다양한 로그 데이터)

넷째, 복잡한 데이터 구조를 가진 애플리케이션의 경우 RDBMS를 선택하는 것이 좋습니다. 왜냐하면 조인 연산을 통해 여러 테이블의 데이터를 결합할 수 있기 때문입니다.
RDBMS는 데이터 간의 관계를 쉽게 표현할 수 있기 때문입니다

읽기를 자주 하지만, 데이터 변경은 자주 없는 경우 NoSQL이 좋습니다 
데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 하기 떄문에

따라서, 애플리케이션의 요구 사항을 분석하고, 적절한 데이터베이스를 선택하는 것이 중요합니다.
SQL을 선택해서 복잡한 JOIN문을 만들지 않도록 설계하여 단점을 없앨 수도 있고
NoSQL을 선택해서 중복 데이터를 줄이는 방법으로 설계해서 단점을 없앨 수도 있습니다.

## 왜 NoSQL이 확장성이 좋은지?
### 데이터베이스 확장 
수직적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)

수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)


SQL 데이터베이스와 NoSQL 데이터베이스의 차이점은 확장성입니다. 

SQL 데이터베이스는 대부분의 상황에서 수직적으로 확장할 수 있습니다. 즉, CPU, RAM 또는 SSD 용량을 추가하여 단일 서버의 부하를 늘릴 수 있습니다.

NoSQL 데이터베이스는 수평적 확장이 가능합니다. 샤딩이라는 프로세스를 통해 더 많은 트래픽을 처리할 수 있는데, 샤딩은 NoSQL 데이터베이스에 더 많은 서버를 추가합니다. 수평 확장은 수직 확장보다 전체 용량이 더 크기 
때문에 자주 변경되는 대규모 데이터 세트에 NoSQL 데이터베이스를 선택하는 것이 좋습니다. 예를 들어 이미지나 동영상과 같은 대용량 데이터 개체가 있는 경우 NoSQL 데이터베이스를 사용할 수 있습니다. SQL 데이터베이스는 이러한 개체를 효과적으로 처리할 수 없으므로 데이터 요구 사항을 충족하기 어렵습니다.

### RDB 수평확장
![image](https://github.com/jyzayu/tech-interview/assets/55649979/bd7985e1-c816-4151-907f-52332bd6e60c)

샤딩을 통해 수평확장을 할 수 있습니다. 수평확장을 하면 인스턴스 2개로 데이터가 나누어 집니다.
두 인스턴스에 같은 데이터가 들어가면 수평확장으로서의 의미가 없습니다.

 ![image](https://github.com/jyzayu/tech-interview/assets/55649979/66581a01-5a6c-4c87-9139-d7cef33c4834)
 ![image](https://github.com/jyzayu/tech-interview/assets/55649979/622d2d9f-883e-4517-b1cb-82afc65897ab)

 위의 데이터를 수평확장하려면 A 인스턴스 B인스턴스로 각각 2개씩 데이터가 나누어 집니다.  
여기서 인스턴스를 1개 더 추가한다면 새로운 규칙으로 다시 데이터 구간을 나누어야 합니다. 
데이터 위치를 알기 위한 그림의 범위-디바이스 테이블도 수정돼야합니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/217f7c9e-8f4f-4864-a0b2-90936c3ff578)

그리고 만약 여러 테이블이 있는 경우 최악의 경우 위 그림처럼 연관된 테이블이 각 다른 인스턴스에 저장된다면?
1사용자에 대한 관계와 영상을 조회하기 위해 A,B,C 인스턴스 모두에 접근해야 합니다. 
그렇다고 데이터를 NoSQL처럼 중복해서 저장하면 일관성(Consistency)이 떨어져 정상적인 Join관 ACID트랜잭션 기능을 사용할 수가 없다.
이처럼 관계가 복잡하고 데이터가 많아질수록 RDB 수평확장에 대한 관리가 복잡해지는 것을 알 수 있습니다.



### NoSQL 수평확장
NoSQL은 특정 컬렉션에 모든 데이터가 저장되는 형태로 데이터 중복이 있습니다. 분산을 시킬 때는 단순히 
구간만 정해서 자르면 됩니다. 수평확장을 하고 인스턴스가 추가돼도 1번 사용자가 본 
영상 정보는 모두 A인스턴스에 있기 때문에 관계를 위해서 범위-디바이스 테이블이 많이 필요하지 않습니다. 
따라서 수평확장이 RDB보다 간단합니다

## 왜 NoSQL은 일관성이 떨어지는지? 
### ACID
 트랜잭션이란 상호작용 및 작업 수행의 논리적 단위입니다. 
 DBMS는 트랜잭션에 대해 ACID 속성들을 보장하고자 합니다. 

원자성(Atomicity): 원자성은 트랜잭션과 관련된 작업이 모두 수행되거나,
 모두 수행되지 않음을 보장합니다. 가령 자금 이체는 성공하거나 실패할 수만 있으며,
  한쪽에서 돈을 출금했으나 다른 쪽에서 입금에 실패하는 등 중간 단계까지만 수행되는 일이 없어야 한다.

일관성(Consistency): 트랜잭션의 처리 이후에도 일관성 있는 데이터베이스 상태를 유지할 수 있어야 합니다. 무결성을 해치는 트랜잭션은 중단입니다. 가령 모든 계좌는 0 이상의 잔액을 가져야 한다는 제약이 있는 경우, 가지고 있는 돈보다 큰 금액을 송금하는 트랜잭션은 중단입니다. ACID에서의 일관성은 “같은 시점의 요청에 대한 응답이 같아야 함”을 의미하는 통상의 개념과는 달리, “트랜잭션 수행이 규칙에 위반되지 않아야 함”을 의미함에 유의하라.

고립성(Isolation): 한 트랜잭션의 처리 도중에 다른 작업이 끼어들지 못하도록 보장합니다. 즉, 트랜잭션 외부에서는 중간 단계 상태를 읽을 수 없다. 고립성은 직렬성(serializability)으로 칭해지기도 하는데, 여러 트랜잭션의 처리 결과가 트랜잭션들을 순차적으로 처리했을 때의 결과와 같다면 고립성이 보장된 것입니다.

영구성(Durability): 성공적으로 처리된 트랜잭션의 작업은 데이터베이스에 영구적으로 반영입니다.

ACID로 하여금 트랜잭션이 안전하게 처리됨을 보장할 수 있습니다. 그러나 실제 서비스 환경에서는 성능 향상 등의 이유로 ACID를 유연하게 적용하곤 합니다. 가령 고립성 수준(isolation level)을 완화해 병행처리를 허용, 초당 트랜잭션 처리량(Transaction Per Second, TPS)을 증대시킬 수 있습니다.

고립성 수준을 완화하면 동시성(concurrency)이 증가하는 것에 반해 일관성이 저하입니다. 다시 말해 고립성 수준을 완화해 병렬처리로 성능을 확보할 수 있지만, 오염된 읽기(Dirty Read), 비-반복가능한 읽기(Non-repeatable Read), 유령 데이터(Phantom) 등 여러 현상들로부터 일관성을 해칠 수 있습니다.

### BASE

BASE는 ACID와는 대조적으로 일관성과 고립성을 희생하고 가용성과 성능을 중시한 속성들입니다. 

기본적으로 가용한(Basically Available): 다수의 저장소에 복사본을 저장하는 등의 방법으로 높은 수준의 가용성을 보장합니다. 일부 서버가 장애 상황에 처하더라도 나머지가 요청을 처리합니다.

유연한 상태(Soft-state): 유연한 상태 하에서 데이터 복사본은 일관적이지 않을 수 있으며, 시스템의 상태가 시간에 따라 변화할 수 있습니다. 심지어 아래에서 살펴볼 ‘궁극적 일관성’에 의해 입력이 없는 상황에서도 상태가 변할 수 있습니다.

궁극적 일관성(Eventually consistency): 한 서버에서의 변경사항은 반드시 다른 장치들에게 전파돼야 합니다. 이 과정에서 상태는 일시적으로 비일관적일 수 있으나, 궁극적으로는 일관성을 찾는다.
관계형 데이터베이스 관리 시스템(Relational Database Management System, RDBMS) 및 일반적인 시스템에서 주로 논의되는 ACID와는 달리, BASE는 NoSQL(Not only SQL) 및 분산 시스템의 특성을 보인다. 


다음 그림은 ACID와 BASE를 비교해 표로 정리한 것입니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/7fce8174-db72-457e-9416-ae7ce71e9099)

위 그림에서 BASE에 해당하는 항목들을 잘 살펴보면 일관성과 가용성 사이의 트레이드-오프(trade-off)가 있음을 알 수 있습니다. 이는 잠시 후 살펴볼 CAP 이론과 PACELC 이론에서 자세히 다룰 것입니다.




### CAP 이론
![image](https://github.com/jyzayu/tech-interview/assets/55649979/2a9c0803-4e2e-4711-97a8-bb0170c9c6d5)


CAP 이론은 분산 시스템에서 일관성, 가용성, 분할 허용의 세 속성을 모두 만족할 수 없다는 트릴레마에 관한 이론이다. PODC 2000에서 Brewer에 의해 추측으로 제시됐고, 2002년 Gilbert 및 Lynch에 의해 증명됐다. 아래 내용은 Gilbert 및 Lynch의 논문을 기준으로 한다. 

- 일관성(Consistency): 분산 시스템에서의 요청 및 응답 과정이 마치 한 노드에서 실행되는 것처럼 동작해야 한다.
- 가용성(Availability): 분산 시스템이 지속해서 가용하기 위해서 장애 없는(non-failing) 노드에 수신된 모든 요청은 반드시 응답돼야 한다.
- 분할 허용(Partition tolerance): 네트워크 분할 상황에서 서로 다른 구역에 있는 노드 간의 통신은 손실된다. 분할 허용하에서는 통신 문제로부터 메시지를 주고받지 못하더라도 서비스가 동작한다.

트릴레마에 따라 분산 시스템 설계는 다음의 선택지를 갖는다.

- CA: 일관성과 가용성을 충족하지만 분할 허용을 충족하지 못한다. 데이터에 대한 강한 신뢰를 부여할 수 있지만, 네트워크 문제가 시스템의 중단을 야기할 수 있다.
- CP: 일관성과 분할 허용을 충족하지만 가용성을 충족하지 못한다. 높은 확장성으로부터 성능을 확보할 수 있지만 일부 데이터가 비가용할 수 있다.
- AP: 가용성과 분할 허용을 충족하지만 일관성을 충족하지 못한다. 부정확한 응답을 허용하는 고성능 시스템에 적합하다.

 CAP 이론은 분할 허용과 일관성 및 가용성 속성을 동등하게 취급하지만, 사실 분산 시스템에서 네트워크 장애는 항시 일어날 가능성이 존재한다. 다시 말해 P를 배제하고 CA를 선택하려면 절대로 장애가 발생하지 않는 네트워크를 구성해야 하는데, 이는 불가능하다. 따라서 CAP 이론은 “분산 시스템에서 네트워크 장애가 발생할 시 일관성(CP)과 가용성(AP) 중 하나를 선택해야 한다”는 의미로 해석된다.
