
SQL vs NoSQL

### RDBMS의 개념과 장단점
RDBMS는 데이터를 테이블 형식으로 저장합니다. 각 테이블은 행과 열로 구성되며, SQL을 사용하여 데이터를 관리합니다.

장점
- 정교한 쿼리 기능:
복잡한 쿼리와 조인을 지원하여 관계형 데이터를 쉽게 조작하고 검색할 수 있습니다.
- 데이터 무결성:
ACID(Atomicity, Consistency, Isolation, Durability) 속성을 통해 데이터 무결성을 보장합니다.
- 표준화:
SQL은 표준화된 언어로 다양한 관계형 데이터베이스 시스템(MySQL, PostgreSQL, Oracle, MS SQL 등)에서 사용 가능합니다.
- 스키마 기반:
명확한 스키마 정의를 통해 데이터 구조를 엄격하게 관리할 수 있습니다.
- 트랜잭션 관리:
강력한 트랜잭션 관리 기능을 제공하여 여러 연산을 하나의 단위로 처리하고 일관성을 유지할 수 있습니다.

단점
- 유연성 부족:
스키마가 고정되어 있어 데이터 구조를 변경하기 어려울 수 있습니다.
- 확장성 제한
수평 확장이 어려워 대규모 분산 시스템에서 성능 저하가 발생할 수 있습니다.
- 복잡성
복잡한 관계형 데이터 모델링이 필요하며, 대규모 데이터베이스에서는 성능 최적화가 어려울 수 있습니다.

### NoSQL의 개념과 장단점
NoSQL은 다양한 데이터 모델을 지원합니다. NoSQL은 SQL을 사용하지 않으며, 키-밸류, 도큐먼트, 컬럼 패밀리, 그래프 등의 데이터 모델을 지원합니다.

장점
- 유연한 스키마
스키마가 없거나 동적 스키마를 지원하여 데이터 구조를 유연하게 변경할 수 있습니다.
스키마가 확정되고 데이터가 많이 쌓인경우 스키마를 수정하면 리스크가 크기 때문에 유연한 스키마가 이점일 수 있습니다.
- 수평 확장 용이
 쉽게 수평 확장할 수 있어 대규모 분산 시스템에 적합합니다.
- 다양한 데이터 모델
키-값 저장소, 문서 지향 데이터베이스, 그래프 데이터베이스, 컬럼 지향 저장소 등 다양한 데이터 모델을 지원합니다.
- 고성능
특정 사용 사례에 최적화되어 빠른 읽기 및 쓰기 성능을 제공합니다.

단점
- 제한된 쿼리 기능:
복잡한 쿼리와 조인을 지원하지 않거나 제한적으로 지원하여 데이터 조작이 복잡할 수 있습니다.
- 데이터 무결성 보장 어려움:
ACID 속성 지원이 제한적이거나 데이터 일관성을 보장하기 어려울 수 있습니다.


### 역정규화
쿼리 프로세싱을 간단하게 하거나 최적화하기 
위해서 또는 사용자의 데이터를 특정한 데이터 모델에 맞추기 위해서 
같은 데이터를 여러 도큐먼트나 테이블에 복제하여 중복하는 것을 허용합니다.

### 비정규화로 인한 트레이드 오프  
쿼리당 I/O 또는 쿼리 데이터 사이즈  VS 전체 데이터 사이즈 

비정규화하면 쿼리 수행을 위한 모든 데이터를 한 곳에 모아놓고 
쿼리를 수행하기 때문에 쿼리 수행을 위한 I/O 숫자를 줄여 전체 성능을
향상시킬 수 있습니다. 

쿼리 수행의 복잡도 VS 전체 데이터 사이즈

 연속적인 JOIN은 쿼리 프로세스의 복잡도를 증가시킵니다. 
역정규화하면 1:N관계를 최소화하여 JOIN연산을 줄여 복잡도를 감소시킵니다.


 수평확장에 유리하기 떄문에 데이터 사이즈가 커지는 것에 관대합니다.
## NoSQL 데이터 모델링 절차 
다음과 같은 절차를 통해서 NoSQL의 데이터 모델링이 진행 됩니다.


- 데이터 모델 파악하기

- 데이터 출력 형태 디자인(쿼리 결과 디자인)

- 패턴을 이용한 데이터 모델링

- 최적화에 필요한 기능 리스팅

- 후보 NoSQL 선정과 테스트

- 데이터 모델을 선정한 NoSQL에 최적화 및 하드웨어 디자인

### 데이터 모델 파악하기
RDBMS든 NoSQL이든 먼저 데이터 모델을 파악해야 합니다.
어떤 데이터 개체가 있고 데이터 개체 간의 관계가 어떻게 되는지를 파악합니다.
해당 과정 없이 바로 어플리케이션 관점에서 접근하면 저장할 데이터에 대한 명확한 이해 없이
데이터 모델링을 하는 것이기 때문에 문제가 생길 수 있습니다.


다음 그림은 간단한 블로그 시스템의 데이터 모델입니다.

- 사용자 ID를 기반으로 블로그의 분류를 가집니다.

- 분류별로 글을 작성할 수 있습니다.

- 글에 파일을 첨부할 수 있습니다.

- 댓글을 달 수 있습니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/71cc3e4f-8f02-41f1-bf3e-84ce9402ece7)

### 데이터 출력 형태 디자인 (쿼리 결과 디자인)
데이터 모델을 기준으로 어플리케이션에 쿼리 되는 결과 값을 정합니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/9d0a2684-1912-4c29-b3c6-45dca12e6560)

출력화면을 나타낸 것 입니다.

- 블로그 사용자의 포스팅 분류 명들을 목록으로 출력합니다.

- 포스팅 출력 화면은 상단 부터 포스팅 분류명과 제목, 포스팅 날짜, 본문을 출력합니다.

- 차례대로 첨부 파일의 업로드 날짜와 파일명을 출력하고 파일에 대한 링크를 포함시킵니다.

- 댓글에 작정일과 작정자 이름, 댓글 내용을 출력하며 작성자 이름에 이메일 링크를 답니다.

쿼리 결과 값으로 데이터 형태를 나타냅니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/4df81ca6-defd-4654-a4b0-a79566eca14c)

### 패턴을 이용한 데이터 모델링
NoSQL은 Sorting,Grouping,Join 등의 연산을 제공하지 않기 때문에 
NoSQL의 Put/Get 만으로 데이터를 가져 올수 있게 테이블을 다시 정의합니다.


![image](https://github.com/jyzayu/tech-interview/assets/55649979/7a30ee8e-192b-492b-ad9c-c4a42e0ef627)

블로그 NoSQL 테이블 구조를 나타낸 것 입니다.

Ordered Key/Value Store의 경우 그림과 같이 Key를 생성하면

postId를 순서대로 증가해 가면서 사용자 글이 정렬 되는 기능을 합니다.

검색시 특정 userId의 postId가 순서대로 출력되다 userId가 바뀌면
해당 post부터 다른 user가 장석한 post이기 때문에 그룹화 기능이 됩니다.

### 최적화에 필요한 기능 리스팅
첨부 파일(Attachment)은 Document Store를 고려해야 합니다. 첨부 파일은 Posting이 작성된 후 레코드가 추가되며 변경이 거의 없다. 또한 많은 양이 아니기 때문에 하나의 필드에 저장할수 있습니다.


카테고리(category)가 있기 때문에 카테고리 별로 분류되어 검색이 가능해야 합니다.
카테고리에 따라 Posting을 출력하려면 Posting의 카테고리 필드에 
저장되고 조건에 따라 검색이 가능해야 합니다. 
이런 이유로 카테고리는 NoSQL의 Secondary Index를 고려해야 합니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/0c5c0e16-ba39-472a-9dde-9d98cc0d4dd1)

### 후보 NoSQL 선정과 테스트
이렇게 모델링한 데이터 구조를 효과적으로 실행할 수 있는 NoSQL을 찾고
해당 NoSQL의 특성, 부하, 안정성, 확장성 등의 테스트를 모두 거친후 선택해야 합니다.

또한 각 서비스에 대하여 데이터 형태와 업무의 목적에 따라 맞는
여러개의 NoSQL을 복합하여 사용할 수도 있습니다.

### 데이터 모델을 선정한 NoSQL에 최정화 및 하드웨어 디자인
마지막으로 선택한 NoSQL을 기반으로 어플리케이션 인터페이스 설계와 하드웨어 디자인을 진행하면 됩니다.



### RDBMS와 NoSQL의 선택 기준
무엇을 선택할지는 주로 애플리케이션의 요구 사항과 데이터 특성에 따라 결정됩니다.
다음과 같은 기준으로 고려해볼 수 있습니다.

- 데이터의 구조와 무결성은 어떤가?

정형 데이터이고 데이터 무결성이 중요하다면 RDBMS를 선택.

비정형 데이터이거나 데이터 구조가 자주 변한다면 NoSQL을 선택.

- 트래픽 규모와 확장성 요구 사항은 어떤가?

트래픽이 많고 수평 확장이 필요하다면 NoSQL을 선택.

상대적으로 트래픽이 적고 수직 확장이 가능하다면 RDBMS를 선택.


- 쿼리와 트랜잭션 요구 사항은 어떤가?

복잡한 쿼리와 트랜잭션이 필요하다면 RDBMS를 선택.

단순한 쿼리와 트랜잭션이 필요하다면 NoSQL을 선택.





## 왜 NoSQL이 확장성이 좋은지?
### 데이터베이스 확장 
수직적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (ex. CPU 업그레이드)

수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)


SQL 데이터베이스와 NoSQL 데이터베이스의 차이점은 확장성입니다. 

SQL 데이터베이스는 대부분의 상황에서 수직적으로 확장할 수 있습니다. 즉, CPU, RAM 또는 SSD 용량을 추가하여 단일 서버의 부하를 늘릴 수 있습니다.

NoSQL 데이터베이스는 수평적 확장이 가능합니다. 샤딩이라는 프로세스를 통해 더 많은 트래픽을 처리할 수 있는데, 샤딩은 NoSQL 데이터베이스에 더 많은 서버를 추가합니다. 수평 확장은 수직 확장보다 전체 용량이 더 크기 
때문에 자주 변경되는 대규모 데이터 세트에 NoSQL 데이터베이스를 선택하는 것이 좋습니다. 예를 들어 이미지나 동영상과 같은 대용량 데이터 개체가 있는 경우 NoSQL 데이터베이스를 사용할 수 있습니다. SQL 데이터베이스는 이러한 개체를 효과적으로 처리할 수 없으므로 데이터 요구 사항을 충족하기 어렵습니다.

### RDB 수평확장
![image](https://github.com/jyzayu/tech-interview/assets/55649979/bd7985e1-c816-4151-907f-52332bd6e60c)

RDBMS 에서 샤딩을 통해 수평확장 하는 경우를 보겠습니다. 수평확장을 하면 인스턴스 2개로 데이터가 나누어 집니다.
두 인스턴스에 같은 데이터가 들어가면 수평확장으로서의 의미가 없습니다.

 ![image](https://github.com/jyzayu/tech-interview/assets/55649979/66581a01-5a6c-4c87-9139-d7cef33c4834)
 ![image](https://github.com/jyzayu/tech-interview/assets/55649979/622d2d9f-883e-4517-b1cb-82afc65897ab)

 위의 데이터를 수평확장하려면 A 인스턴스 B인스턴스로 각각 2개씩 데이터가 나누어 집니다.  
여기서 인스턴스를 1개 더 추가한다면 새로운 규칙으로 다시 데이터 구간을 나누어야 합니다. 
데이터 위치를 알기 위한 그림의 범위-디바이스 테이블도 수정돼야합니다.

![image](https://github.com/jyzayu/tech-interview/assets/55649979/217f7c9e-8f4f-4864-a0b2-90936c3ff578)

그리고 만약 여러 테이블이 있으면 최악의 경우 위 그림처럼 연관된 테이블이 각 다른 인스턴스에 저장된다면?
1사용자에 대한 관계와 영상을 조회하기 위해 A,B,C 인스턴스 모두에 접근해야 합니다. 
그렇다고 데이터를 NoSQL처럼 중복해서 저장하면 일관성(Consistency)이 떨어져 정상적인 Join과 ACID트랜잭션 기능을 사용할 수가 없습니다.
이처럼 관계가 복잡하고 데이터가 많아질수록 RDB 수평확장에 대한 관리가 복잡해지는 것을 알 수 있습니다.



### NoSQL 수평확장
NoSQL은 특정 컬렉션에 모든 데이터가 저장되는 형태로 데이터 중복이 있습니다. 분산을 시킬 때는 단순히 
구간만 정해서 자르면 됩니다. 수평확장을 하고 인스턴스가 추가돼도 1번 사용자가 본 
영상 정보는 모두 A인스턴스에 있기 때문에 관계를 위해서 범위-디바이스 테이블이 많이 필요하지 않습니다. 
따라서 수평확장이 RDB보다 간단합니다

## MySQL ACID, MongoDB ACID
MySQL은 전통적인 RDBMS로서 강력한 일관성 보장을 제공하며, MongoDB는 NoSQL 데이터베이스로서 유연성과 확장성에 중점을 두면서도 필요에 따라 일관성을 조절할 수 있습니다.

### ACID
 트랜잭션이란 상호작용 및 작업 수행의 논리적 단위입니다.
 하나의 작업으로서 수행되는 1개 이상의 SQL 명령어의 묶음을 말합니다.
 DBMS는 트랜잭션에 대해 ACID 속성들을 보장하고자 합니다. 

원자성(Atomicity): 원자성은 트랜잭션과 관련된 작업이 모두 수행되거나,
 모두 수행되지 않음을 보장합니다. 가령 자금 이체는 성공하거나 실패할 수만 있으며,
  한쪽에서 돈을 출금했으나 다른 쪽에서 입금에 실패하는 등 중간 단계까지만 수행되는 일이 없어야 합니다.

일관성(Consistency): 트랜잭션의 처리 이후에도 일관성 있는 데이터베이스 상태를 유지할 수 있어야 합니다. 무결성을 해치는 트랜잭션은 중단됩니다. 가령 모든 계좌는 0 이상의 잔액을 가져야 한다는 제약이 있는 경우, 가지고 있는 돈보다 큰 금액을 송금하는 트랜잭션은 중단됩니다. ACID에서의 일관성은 “같은 시점의 요청에 대한 응답이 같아야 함”을 의미하는 통상의 개념과는 달리, “트랜잭션 수행이 규칙에 위반되지 않아야 함”을 의미합니다.
Ex. 게시판에 글을 올릴 때, 제목 길이는 255로 제한되어 있는데 트랜잭션 작업 이후 길이가 변경되면 안되는 것을 말합니다.




고립성(Isolation): 한 트랜잭션의 처리 도중에 다른 작업이 끼어들지 못하도록 보장합니다. 즉, 트랜잭션 외부에서는 중간 단계 상태를 읽을 수 없습니다. 고립성은 직렬성(serializability)으로 칭해지기도 하는데, 여러 트랜잭션의 처리 결과가 트랜잭션들을 순차적으로 처리했을 때의 결과와 같다면 고립성이 보장된 것입니다.

영구성(Durability): 성공적으로 처리된 트랜잭션의 작업은 데이터베이스에 영구적으로 반영됩니다.

ACID로 하여금 트랜잭션이 안전하게 처리됨을 보장할 수 있습니다. 그러나 실제 서비스 환경에서는 성능 향상 등의 이유로 ACID를 유연하게 적용하곤 합니다. 가령 고립성 수준(isolation level)을 완화해 병행처리를 허용, 초당 트랜잭션 처리량(Transaction Per Second, TPS)을 증대시킬 수 있습니다.



## MySQL 기본 스토리지 엔진인 InnoDB 엔진에서 어떻게 ACID를 보장하는지? 
### 원자성 (Atomicity)
다음 개념은 트랜잭션이 작동하는 방식과 관련있습니다.이를 통해 
데이터 무결성을 유지하도록 합니다.

commit: 커밋하는 것은 트랜잭션에서 변경한 내용이 마지막이고 영구적으로 저장
돼야 한다고 확인하는 것입니다.

롤백(Rollback): 롤백(Rollback)은 어떤 문제가 발생하거나 변경을 진행하고 싶지 않다고 결정한 경우 트랜잭션에서 변경한 내용을 다시 실행하지 않는 것을 의미합니다.

세이브 포인트(savePoint): 세이브 포인트는 트랜잭션에서 모든 것이 여전히 정확하고 일관된 지점을 표시하는 것과 같습니다. 나중에 일이 잘못되기 시작하면  처음부터 시작하는 것이 아니라 세이브 포인트로 돌아가  이미 알려진 좋은 상태에서 다시 시작할 수 있습니다.


자동 커밋 모드

기본적으로 MySQL은 자동 커밋 모드에서 작동하므로 각 문은 별도의 트랜잭션으로 취급됩니다. 이로 인해 롤백을 발행하기 전에 INSERT 작업이 커밋될 수 있습니다. 이를 방지하려면 자동 커밋을 해제해야 합니다.
```
SET autocommit = 0;  -- Turn off autocommit
start transaction; -- Start your transaction


-- perform operation
INSERT INTO order_history (product_id, quantity) 
VALUES (1, 10),(2,50),(3,100);

-- commit or rollback  변화를 적용하거나 버리고 싶으면 커밋 롤백중 선택합니다.
COMMIT; --To commit the changes
ROLLBACK; --To roll back the changes (simulate an error)


```


rollback 수행후 테이블을 확인하면 반영되지 않은 것을 확인할 수 있습니다.

즉, autocomimt 설정,  commit, rollback 기능을 통해 원자성을 보장합니다.

### 일관성(Consistency)
주로 충돌로부터 데이터를 보호하기 위한 내부 InnoDB 처리로 일관성을 보장합니다.

InnoDB 충돌 복구, InnoDB Doublewrite 버퍼를 통해 일관성을 보장합니다.
InnoDB doublewrite 버퍼는 반쯤 작성된 페이지에서 복구하기 위해 구현되었습니다. 이는 InnoDB가 디스크에 페이지를 작성하는 동안 전원 장애가 발생했을 때 발생할 수 있습니다. InnoDB는 해당 페이지를 읽었을 때 페이지 체크섬의 불일치로 인한 손상을 발견할 수 있습니다. 그러나 복구하기 위해서는 페이지의 온전한 복사본이 필요합니다.

doublewrite 버퍼는 이러한 복사본을 제공합니다.

InnoDB가 페이지를 디스크로 플러시할 때마다 먼저 이중 쓰기 버퍼에 기록됩니다. 버퍼를 디스크로 안전하게 플러시할 때만 InnoDB는 페이지를 최종 목적지에 기록합니다. 복구할 때 InnoDB는 이중 쓰기 버퍼를 검색하고 버퍼의 각 유효한 페이지에 대해 데이터 파일의 페이지도 유효한지 확인합니다.

doublewrite buffer 설정을 위해 여러 변수가 제공되는데 그 중 하나로 

innodb_doublewrite 변수는 doublewrite 버퍼가 활성화되는지 여부를 제어합니다. 대부분의 경우 기본적으로 활성화됩니다. doublewrite 버퍼를 비활성화하려면 innodb_doublewrite를 OFF로 설정하십시오. 예를 들어 벤치마크를 수행할 때처럼 데이터 무결성보다 성능에 더 관심이 있는 경우 doublewrite 버퍼를 비활성화하는 것을 고려하십시오.

InnoDB 충돌 복구는 예상치 못한 MySQL 서버 종료를 복구하기 위해 MySQL 서버를 다시 시작하는 것이 유일한 요구 사항입니다. InnoDB는 자동으로 로그를 확인하고 데이터베이스를 현재로 롤포워드합니다. InnoDB는 충돌 당시 존재했던 커밋되지 않은 트랜잭션을 자동으로 롤백합니다.


### 격리성 (Isolation)
autocommit 설정
Isolation level을 SET_TRANSACTION 명령어로 설정합니다.

InnoDB는 SQL:1992 표준에서 설명하는 네 가지 트랜잭션 격리 수준, 
즉 READ UNCOMITED, READ COMMITTED, REAPTable READ, Serializable 모두를 제공합니다.
 InnoDB의 기본 격리 수준은 REAPTable READ입니다.

 각 격리 수준을 간단하게 보겠습니다.
- Read Uncommitted: 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽을 수 있습니다.
- Read Committed: 다른 트랜잭션에서 커밋된 데이터만 읽을 수 있습니다.
- Repeatable Read: 트랜잭션이 시작된 후 다른 트랜잭션에서 커밋된 변경 사항을 볼 수 없습니다.
- Serializable: 가장 높은 격리 수준으로, 트랜잭션이 직렬적으로 실행되는 것처럼 동작합니다.

사용자는 SET TRANSACTION 문을 사용하여 단일 세션 또는 이후의 모든 연결에 대해 격리 수준을 변경할 수 있습니다. 모든 연결에 대해 서버의 기본 격리 수준을 설정하려면 명령줄 또는 옵션 파일에서 --transaction-isolation 옵션을 사용합니다.

InnoDB는 여기에 설명된 각각의 트랜잭션 격리 수준을 서로 다른 Locking 전략을 사용하여 지원합니다. ACID 준수가 중요한 중요한 데이터에 대한 작업에 대해 기본 REPATEBLE READ 수준과 높은 일관성을 적용할 수 있습니다. 또는 정확한 일관성과 반복 가능한 결과가 잠금에 대한 오버헤드를 최소화하는 것보다 덜 중요한 대량 보고와 같은 상황에서 READ COMITED 또는 READ UNCOMITED로 일관성 규칙을 완화할 수 있습니다. SERIABLE은 REPATEBLE READ보다 훨씬 더 엄격한 규칙을 적용하며, XA 트랜잭션 및 동시성 및 데드락이 있는 문제를 해결하는 데 주로 사용됩니다.

InnoDB Locking에 대한 세부정보는 information_schema table 과 performance schema table 인 data_locks, data_lock_waits 테이블에서 볼 수 있습니다. 

### 일관성 (Durability)
내구성은 특정 하드웨어 구성과 상호 작용하는 MySQL 소프트웨어 기능을 통해 보장합니다. CPU, 네트워크 및 스토리지 장치의 기능에 따라 많은 가능성이 있기 때문에 이 측면은 구체적인 지침을 제공하기가 가장 복잡합니다. (그리고 이러한 지침은 "새로운 하드웨어 구입"의 형태를 취할 수도 있습니다.)
InnoDB doublewrite buffer, 디스크 드라이브, SSD 또는 RAID 어레이와 같은 저장 장치의 쓰기 버퍼,
저장 장치의 배터리 백업 캐시 등이 관련있습니다. 
fsync() 시스템 호출을 지원합니다.

## MongoDB에서 ACID 트랜잭션이 어떻게 동작하는지? 
몽고DB는 2018년 버전 4.0에서 다중 문서 ACID 트랜잭션 지원을 추가했으며 2019년 버전 4.2에서 분산 다중 문서 ACID 트랜잭션 지원을 확장했습니다.

MongoDB의 문서 모델은 관련 데이터를 하나의 문서에 함께 저장할 수 있도록 해줍니다. 문서 모델은 원자 문서 업데이트와 결합하여 대부분의 사용 사례에서 트랜잭션의 필요성을 제거합니다. 그럼에도 불구하고 진정한 다중 문서, 다중 수집 MongoDB 트랜잭션이 가장 좋은 선택인 경우가 있습니다.

MongoDB 트랜잭션은 다른 데이터베이스의 트랜잭션과 유사하게 작동합니다. 트랜잭션을 사용하려면 드라이버를 통해 MongoDB 세션을 시작하십시오. 그런 다음 해당 세션을 사용하여 그룹의 데이터베이스 작업을 실행합니다. 여러 문서, 여러 컬렉션 및 여러 샤드에서 CRUD(생성, 읽기, 업데이트 및 삭제) 작업을 실행할 수 있습니다.

### 원자성
다음 기능에 대한 API를 제공하여 원자성을 보장합니다.
- starts a transaction
- executes the specified operations
- commits the result (or aborts on error)

multi document 에 대해 트랜잭션이 수행됐을 때,
단일 document에 대해 원자성을 보장했지만 4.0부터 multi document를
원자적으로 처리할 수 있게 됐습니다. 

### 일관성
Read Concern은 데이터 읽기 작업이 데이터베이스에서 어느 정도의 일관성을 보장해야 하는지를 정의합니다. 이는 트랜잭션의 일관성을 보장하는 데 중요한 역할을 합니다. MongoDB에서 제공하는 주요 Read Concern 레벨은 다음과 같습니다:

- "local": 로컬 복제본에서 즉시 가용한 데이터를 반환합니다. 일관성을 보장하지는 않지만, 가장 빠른 읽기 성능을 제공합니다.
- "available": 가용한 데이터를 반환하며, 읽기 일관성에 대한 보장은 하지 않습니다.
- "majority": 대부분의 복제본에서 확인된 데이터를 반환하여 읽기 일관성을 보장합니다.
- "linearizable": 가장 최근에 쓰여진 데이터를 읽어야 함을 보장합니다. 이는 강력한 일관성을 제공합니다.
- "snapshot": 트랜잭션의 스냅샷을 기준으로 데이터를 읽습니다. 트랜잭션이 시작된 시점의 일관된 데이터를 보장합니다.


### 격리성
MongoDB는 기본적으로 스냅샷 격리(Snapshot Isolation) 수준을 제공합니다.

1. 스냅샷 격리(Snapshot Isolation)

트랜잭션 내에서 읽기 작업:

트랜잭션이 시작될 때의 데이터 상태를 기준으로 수행됩니다.
트랜잭션 내의 모든 읽기 작업은 동일한 일관된 스냅샷을 참조하므로, 트랜잭션이 진행되는 동안 다른 트랜잭션에 의해 변경된 데이터를 보지 않습니다.

트랜잭션 내에서 쓰기 작업:

다른 트랜잭션이 커밋한 변경 사항을 반영할 수 있습니다.
쓰기 작업은 트랜잭션 내에서 발생한 모든 변경 사항을 보고 반영할 수 있습니다.

2. 다중 문서 트랜잭션의 격리

MongoDB 4.0부터 다중 문서 트랜잭션이 도입되면서 스냅샷 격리를 적용합니다.
다중 문서 트랜잭션은 기본적으로 스냅샷 격리를 제공하여 
트랜잭션 간 간섭을 방지하고 데이터 일관성을 유지합니다.

3. 단일 문서 연산의 격리

단일 문서에 대한 연산은 원자적으로 수행되며, 단일 문서 연산은 기본적으로 고립성을 제공합니다.
단일 문서에 대한 모든 변경 작업은 동시에 발생하는 다른 연산과 독립적으로 처리됩니다.


### 지속성 
Write Concern은 데이터 쓰기 작업이 얼마나 안전하게 기록되어야 하는지를 정의합니다. 이는 트랜잭션의 지속성을 보장하는 데 중요한 역할을 합니다. MongoDB에서 제공하는 주요 Write Concern 레벨은 다음과 같습니다:

- "w: 1": 기본 설정으로, 쓰기 작업이 로컬 복제본에 기록되면 완료된 것으로 간주합니다.
- "w: majority": 대부분의 복제본에 쓰기 작업이 기록될 때까지 대기하여 지속성을 보장합니다.
- "w: all": 모든 복제본에 쓰기 작업이 기록될 때까지 대기합니다.


### 언제 MongoDB에서 transaction을 쓰는 것이 좋을지? 
document 모델을 활용하는 애플리케이션의 80~90%는 몽고DB에서 트랜잭션을 활용할 필요가 없을 것으로 추정됩니다.

나머지 10%-20% 애플리케이션의 경우 multi document transaction이 가능합니다.

transaction이 필요한 애플리케이션에는 일반적으로 서로 다른 당사자 간에 가치가 교환되는 use case가 있습니다
다중 문서 트랜잭션의 이점을 얻을 수 있는 응용 프로그램의 예는 다음과 같습니다

- 결제 처리 시스템 및 거래 플랫폼과 같이 자금을 이동하는 시스템.
- 상품 및 서비스의 소유권이 한 당사자에서 다른 당사자로 이전되는 공급망 및 예약 시스템.
- 요약 레코드뿐만 아니라 상세 레코드에 정보를 저장하는 청구 시스템.

